Lesson 12
create voting API via Express.js routes, using MySQL shell to connect to MySQL 
server to create database and table, then use MySQL shell to perform CRUD operations

check mysql with `mysql --version`

Database: collection of interrelated data, stored in one+ tables related to each other
Table: compsed of rows and columns. column = field, row = record
Query: request for data from database table(s)

check to make sure database doesn't exist with `show databases;`

Start by creating the database with opening MySQL shell with `mysql -u root -p`
after logging in, `mysql>` will show up confirming we are in the shell
    here we can CRUD

create database with the following: `CREATE DATABASE <database name>;`
    SQL convention with all caps helps to differentiate from identifiers like names of
    databases, tables, columns. note: identifiers are case sensitive so a database named
    `elections` will be different from `Elections`
    semicolon must be used to end command or else new command will continue from 
    previous command

select database with: `USE <database name>`

after creating and selecting database, then create table inside that database
`CREATE TABLE <table name>`

{
review the following: 
`CREATE TABLE candidates (
  id INTEGER AUTO_INCREMENT PRIMARY KEY,
  first_name VARCHAR(30) NOT NULL,
  last_name VARCHAR(30) NOT NULL,
  industry_connected BOOLEAN NOT NULL
);`

everything inside `( )` lists details of each column. column names cannot contain spaces,
    and are normally lowercase. each column is seperated by a comma.
datatypes follow column names. 
theoretically since each record could be as long as a book, should limit the number of chars
    being inputted. therefore `30` inside `VARCHAR(30)` to limit input to 30 characters
each table should have an id, especially if it contains unique records. id is designated using 
    the `PRIMARY KEY` and `AUTO_INCREMENT` attributes. `PRIMARY KEY` states each value 
    in column must be unique for each record in the table. Can also be used to link tables 
    together. `AUTO_INCREMENT`` increments each successive row and assigns a new value 
    to `id`. 
        each table can only have one `PRIMARY KEY`
    `NOT NULL` means column must contain a value. so if trying to insert a record into
        `candidates` column with missing values, database will not allow the addition
        note: since `PRIMARY KEY` column must contain a value by definition, does not
            require `NOT NULL` explicitly
}

after creating table, can verify with `DESCRIBE candidates;`
    this describes tables fields and field attributes without table's data/records

{
SQL statements that will input/load data to table: 
    `INSERT INTO candidates (first_name, last_name, industry_connected)
    VALUES ('Ronald', 'Firbank', 1);`

NOTE: the varchar characters must be surrounded by ' ' since they are strings
}

to verify the data added, `SELECT * FROM <table name>;`

adding multiple inserts:
    `INSERT INTO candidates (first_name, last_name, industry_connected)
    VALUES
        ('Virginia', 'Woolf', 1),
        ('Piers', 'Gaveston', 0),
        ('Charles', 'LeRoi', 1),
        ('Katherine', 'Mansfield', 1),
        ('Dora', 'Carrington', 0),
        ('Edward', 'Bellamy', 0),
        ('Montague', 'Summers', 1),
        ('Octavia', 'Butler', 1),
        ('Unica', 'Zurn', 1);`

select specific columns: `SELECT first_name, last_name FROM candidates;`
selectively filtering data can be done with `WHEN` clause:
    `SELECT first_name, industry_connected
    FROM candidates
    WHERE industry_connected = 1;`
filter data to only show `industry_connected` with a value of 1
another example, but to select a specific row:
    `SELECT first_name, last_name, industry_connected
    FROM candidates
    WHERE id = 5;`

to save and share these databases, create `./db/db.sql` and `./db/schema.sql`
    create `seeds.sql` for data insertion
    in `db.sql`, create database and use it the same as above
    in `schema.sql` create table with columns the same as above
        since we already have this table created in the shell, need to delete (DROP) the 
        database via shell command: `DROP DATABASE election;`

now to recreate `election` database or to execute script files:    `source db/db.sql`
next, create table and columns from `schema.sql` with:      `source db/schema.sql`
check with: `DESCRIBE candidates;`

now create `./db/seeds.sql` and populate candidates table with data
execute file with: `source db/seeds.sql`
    check with: `SELECT * FROM candidates;`

can change table with the `UPDATE` keyword, ex:
    `UPDATE candidates
    SET industry_connected = 1
    WHERE id = 3;`

to delete data, use `DELETE FROM` keywords, ex:
    `DELETE FROM candidates
    WHERE first_name = "Montague";`
when deleting, ID that is being autogenerated will not change for the rows following the 
row that was deleted. and when new rows are added, they will continue from the last row.
this way there will not be duplicate id's

        side note: enter `quit` in MySQL shell to exit. type `help` in MySQL for more commands

12.2
- going to initialize Node.js, connect it to MySQL, then execute SQL queries in Express.js
    api routes using MySQL methods. API endpoints will be tested in insomnia.

initialize node with `npm init --y`, then create `.gitignore` and include `node_modules/`
install express and mysql2 with `npm install express mysql2'
    mysql2 will allow us to connect express API routes to MySQL database and execute SQL 
    commands to perform CRUD operations
install jest with `npm install jest --save-dev`, then change inside package.json to "test": "jest"

**new: to start express.js server, update `scripts` code in `package.json` to match:
`"scripts": {
  "test": "jest",
  "start": "node server.js"
},`

run MySQL shell: `mysql -u root -p`
check database: `SHOW DATABASES;` then select db with `USE election;`
check table: `SHOW TABLES;` then check if data present with `SELECT * FROM candidates;`
    if any errors, then create and start db again with `source db/db.sql`

create express.js server:
create server.js in root, define express, add port, middleware, and app.listen
create `app.get(`) for the root directory `('/', () => { })` then `npm start` and load 
    `localhost:PORT` to test that server is working and connection is established

create `app.use()` for 404 message (can remove `app.get()` for directory since connection made)

load `mysql2` into server with `const mysql = require('mysql2');`

// Connect to database
const db = mysql.createConnection(
  {
    host: 'localhost',
    // Your MySQL username,
    user: 'root',
    // Your MySQL password
    password: '',
    database: 'election'
  },
  console.log('Connected to the election database.')
);

`db.query()` runs SQL query and executes callback

create API endpoint to retrieve all candidates from `candidates` table
front end can loop and parse object to display list of candidate names

12.3
Relational Data (tables with their own data can be linked to other tables via primary keys)

foreign key: field in one table that references primary key of another table
`ALTER TABLE` keyword allows us to add to a table that's already set up so that we don't loose
any preexisting data (ex adding column for foreign key)

can delete tables with `DROP TABLE` statement

different types of relationships: one-to-one or one-to-many. in this lesson, one-to-many

`JOIN` keyword merges 2+ tables together, filling fk with actual data
    otherwise, would have to query database twice (one for each party, then merge with JS)
    - inner join, left join, right join, full outer join
    in this case: 
        `SELECT * FROM candidates
        LEFT JOIN parties ON candidates.party_id = parties.id;`

12.4
Normalization: process of organizing relational data to provide the following benefits:
    - each table reps a spec topic (approach adheres to best practice of Separation of Concerns)
    - limits data redundancy
    - allows writing simpler SQL queries
    - less risk for data modification errors since you can refer to an entire record in another
        table by using its primary key. Any changes to that record will happen all in one place.

12.5
create votes table to track votes, by merging multiple tables together
    this allows for specific data being analyzed to be concise and not cluttered
    also can simply reset `votes` table and use for future elections

after creating `votes` table, and resetting tables/seeds with `source` command in MySQL, execute:
    `INSERT INTO votes (voter_id, candidate_id) VALUES(1, 1);
    INSERT INTO votes (voter_id, candidate_id) VALUES(2, 1);
    INSERT INTO votes (voter_id, candidate_id) VALUES(2, 2);`
error on third line, indicating duplicate entry and does not allow it to be added to table.
this is intentional and shows that our code works since we do not want a voter to vote twice.
multiple votes were prevented by setting `vote_id` in `votes` table to `unique_id`

to test the `ON DELETE CASCADE`, execute in MySQL:
    `DELETE FROM voters WHERE id = 2;
    SELECT * FROM votes;`
entire row is deleted from line one and confirmed with line 2.

after creating votes table, execute: 
    `INSERT INTO votes (voter_id, candidate_id) 
    VALUES(3,1), (4,2), (5,2), (6,2), (7,2), (8,3), (9,3);`
this will populate the table. next, can perform a math-related logic via MySQL. in this ex.:
    `SELECT COUNT(candidate_id) FROM votes;`
`COUNT( )` will count how many times a certain field value appears
but in this case `SELECT COUNT( )` will show total votes cast. we want votes per candidate.
so can use `GROUP BY` keyword, which can consolidate several rows of data, grouping by a
shared value (ex. candidate_id). with this keyword, you can then run an aggregate function
to retrieve an average/sum/min value from the group. ex.:
    `SELECT COUNT(candidate_id) FROM votes GROUP BY candidate_id;`

since `candidate_id` is a fk, can join this table with the `candidates` table, then join the
`candidates` table with the `parties` table to pull their party affiliation. execute in MySQL:
    `SELECT candidates.*, parties.name AS party_name, COUNT(candidate_id)
    FROM votes
    LEFT JOIN candidates ON votes.candidate_id = candidates.id
    LEFT JOIN parties ON candidates.party_id = parties.id
    GROUP BY candidate_id;`

following that code, can refine it for easier use for front end and better organization. 
in MySQL, execute:
    `SELECT candidates.*, parties.name AS party_name, COUNT(candidate_id) AS count
    FROM votes
    LEFT JOIN candidates ON votes.candidate_id = candidates.id
    LEFT JOIN parties ON candidates.party_id = parties.id
    GROUP BY candidate_id ORDER BY count DESC;`

12.2.8
question not connecting (cannot complete)